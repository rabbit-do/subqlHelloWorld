"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._n = exports.Hash = void 0;
exports.assertBool = assertBool;
exports.assertHash = assertHash;
exports.assertNumber = assertNumber;
exports.asyncLoop = asyncLoop;
exports.bytesToHex = bytesToHex;
exports.checkOpts = checkOpts;
exports.nextTick = exports.isLE = exports.crypto = exports.createView = void 0;
exports.randomBytes = randomBytes;
exports.rotr = void 0;
exports.toBytes = toBytes;
exports.u8 = exports.u32 = void 0;
exports.wrapConstructor = wrapConstructor;
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;

/*! noble-hashes - MIT License (c) 2021 Paul Miller (paulmillr.com) */
// https://github.com/paulmillr/noble-hashes/pull/13
// prettier-ignore
// helper to protect against older bundlers
const _n = typeof BigInt !== 'undefined' ? BigInt : () => Number.NaN; // Cast array to different type


exports._n = _n;

const u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);

exports.u8 = u8;

const u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4)); // Cast array to view


exports.u32 = u32;

const createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength); // The rotate right (circular right shift) operation for uint32


exports.createView = createView;

const rotr = (word, shift) => word << 32 - shift | word >>> shift;

exports.rotr = rotr;
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44; // There is almost no big endian hardware, but js typed arrays uses platform specific endianess.
// So, just to be sure not to corrupt anything.

exports.isLE = isLE;
if (!isLE) throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({
  length: 256
}, (v, i) => i.toString(16).padStart(2, '0'));

function bytesToHex(uint8a) {
  // pre-caching chars could speed this up 6x.
  let hex = '';

  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }

  return hex;
} // Currently avoid insertion of polyfills with packers (browserify/webpack/etc)
// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here


const nextTick = (() => {
  const nodeRequire = typeof module !== 'undefined' && typeof module.require === 'function' && module.require.bind(module);

  try {
    if (nodeRequire) {
      const {
        setImmediate
      } = nodeRequire('timers');
      return () => new Promise(resolve => setImmediate(resolve));
    }
  } catch (e) {}

  return () => new Promise(resolve => setTimeout(resolve, 0));
})(); // Returns control to thread each 'tick' ms to avoid blocking


exports.nextTick = nextTick;

async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();

  for (let i = 0; i < iters; i++) {
    cb(i); // Date.now() is not monotonic, so in case if clock goes backwards we return return control too

    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick) continue;
    await nextTick();
    ts += diff;
  }
}

function toBytes(data) {
  if (typeof data === 'string') data = new TextEncoder().encode(data);
  if (!(data instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}

function assertNumber(n) {
  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);
}

function assertBool(b) {
  if (typeof b !== 'boolean') {
    throw new Error(`Expected boolean, not ${b}`);
  }
}

function assertHash(hash) {
  if (typeof hash !== 'function' || typeof hash.init !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
  assertNumber(hash.outputLen);
  assertNumber(hash.blockLen);
} // For runtime check if class implements interface


class Hash {
  constructor() {
    this.blockLen = void 0;
    this.outputLen = void 0;
  }

  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }

}

exports.Hash = Hash;

// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;

function checkOpts(def, _opts) {
  if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts))) throw new TypeError('Options should be object or undefined');
  const opts = Object.assign(def, _opts);
  return opts;
}

function wrapConstructor(hashConstructor) {
  const hashC = message => hashConstructor().update(toBytes(message)).digest();

  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;

  hashC.create = () => hashConstructor();

  hashC.init = hashC.create;
  return hashC;
}

function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();

  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;

  hashC.create = opts => hashCons(opts);

  hashC.init = hashC.create;
  return hashC;
}

const crypto = (() => {
  const webCrypto = typeof self === 'object' && 'crypto' in self ? self.crypto : undefined;
  const nodeRequire = typeof module !== 'undefined' && typeof require === 'function';
  return {
    node: nodeRequire && !webCrypto ? require('crypto') : undefined,
    web: webCrypto
  };
})();

exports.crypto = crypto;

function randomBytes() {
  let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;

  if (crypto.web) {
    return crypto.web.getRandomValues(new Uint8Array(bytesLength));
  } else if (crypto.node) {
    return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);
  } else {
    throw new Error("The environment doesn't have randomBytes function");
  }
}